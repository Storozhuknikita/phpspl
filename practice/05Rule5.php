<?php

$array = [1, 5, 6, 8, 2, 2, 0, 3, 4, 9, 7];


function FindDublicates($array)
{
    for($i = 0; $i < count($array); $i++) {
        for($j = 0; $j < count($array); $j++) {
            if ($i != $j) {
                if ($array[$i] == $array[$j]) {
                    return 1;
                }
            }
        }
    }

    // Если дошли до этого места, дубликатов нет
    return 0;
}


echo FindDublicates($array) . PHP_EOL;

/*
Пренебрегая дополнительным шагом в выражении return (как правило, он выполняется один раз),
предположим, что срабатывают оба оператора if (а так и происходит в большинстве случаев).
Тогда внутренний цикл будет пройден за O(2N) шагов. Следовательно, общая производительность
алгоритма составит O(N x 2N)  =  O(2N^2). Последнее правило позволяет пренебречь коэффициентом
2 и записать производительность алгоритма в виде O(N^2).

Возвращаемся к сути асимптотической сложности: нужно выяснить, как поведет себя алгоритм, если N начнет
возрастать. Например, увеличим N в два раза, то есть будем оперировать значением 2N. Теперь, если подставить
фразу в выражение 2N2, получится следующее: 2 x (2N)2 = 2 x 4N2 = 8N2. Это и есть величина 2N2, только умноженная на 4.
Время работы алгоритма увеличится в четыре раза.

Оценим производительность алгоритма, используя упрощенное по правилу выражение O(N2). При подстановке в него 2N получим:
(2N)2 = 4N2. Изначальная величина N2 возросла в четыре раза, как и время работы алгоритма.
Независимо от того, будем мы использовать развернутую формулу 2N2 или ограничимся просто N2,
результат останется прежним: двукратное увеличение сложности задачи замедлит работу алгоритма в четыре раза.
Таким образом, важной здесь является не константа 2, а тот факт, что время работы увеличивается
вместе с увеличением количества вводов N^2.

*/
